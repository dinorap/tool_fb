=== PROJECT CONTEXT EXPORT ===

PROJECT STRUCTURE:
backend/
    .env
    .gitignore
    main.py
    requirements.txt
    test.py
    app/
        api.py
        __init__.py
    core/
        browser.py
        nst.py
        runner.py
        scraper.py
        utils.py
    data/
        post_ids/
            031ca13d-e8fa-400c-a603-df57a2806788.json
            621e1f5d-0c42-481e-9ddd-7abaafce68ed.json

==================================================

--- START FILE: main.py ---
from core.runner import AppRunner

if __name__ == "__main__":
    AppRunner().run()

--- END FILE: main.py ---

--- START FILE: test.py ---
import os
import time
from dotenv import load_dotenv
from core.nst import connect_profile
from core.browser import FBController

load_dotenv()

def test_check_resolution():
    profile_list = os.getenv("PROFILE_IDS", "").split(",")
    profile_id = profile_list[0].strip()
    
    if not profile_id:
        print("‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y PROFILE_IDS")
        return

    print(f"üß™ ƒêang test Profile: {profile_id}")

    try:
        ws_url = connect_profile(profile_id)
        fb = FBController(ws_url)
        fb.profile_id = profile_id
        
        # K·∫øt n·ªëi
        fb.connect() 
        
        # --- [ƒêO·∫†N KI·ªÇM TRA QUAN TR·ªåNG] ---
        # 1. L·∫•y th√¥ng s·ªë k√≠ch th∆∞·ªõc viewport th·ª±c t·∫ø
        vp = fb.page.viewport_size
        print(f"\nüìä K√çCH TH∆Ø·ªöC M√ÄN H√åNH HI·ªÜN T·∫†I: {vp}")
        
        if vp and vp['width'] == 1920 and vp['height'] == 1080:
            print("‚úÖ OK! ƒê√£ Full HD 1920x1080.")
        else:
            print("‚ö†Ô∏è C·∫¢NH B√ÅO: M√†n h√¨nh ch∆∞a Full HD! Bot c√≥ th·ªÉ b·ªã l·ªói giao di·ªán mobile.")

        # 2. M·ªü Facebook v√† ch·ª•p ·∫£nh b·∫±ng ch·ª©ng
        print("üöÄ ƒêang v√†o Facebook ƒë·ªÉ ch·ª•p ·∫£nh...")
        fb.goto("https://www.facebook.com")
        time.sleep(5)
        
        fb.page.screenshot(path="debug_resolution.png")
        print("üì∏ ƒê√£ l∆∞u ·∫£nh: debug_resolution.png (S·∫øp m·ªü l√™n xem c√≥ b·ªã b√© kh√¥ng)\n")
        # -----------------------------------

        # (Ph·∫ßn sau gi·ªØ nguy√™n logic share c≈© ƒë·ªÉ test ti·∫øp...)
        # ...

    except Exception as e:
        print(f"‚ùå L·ªói: {e}")
    finally:
        print("üõë ƒê√≥ng tr√¨nh duy·ªát...")
        try:
            if fb.browser: fb.browser.close()
            if fb.play: fb.play.stop()
        except: pass

if __name__ == "__main__":
    test_check_resolution()
--- END FILE: test.py ---

--- START FILE: app\api.py ---
from multiprocessing import Process
from typing import Optional

from fastapi import Body, FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from core.runner import AppRunner

app = FastAPI(title="NST Tool API", version="1.0.0")

# Cho ph√©p frontend (file tƒ©nh) g·ªçi API qua localhost
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Bi·∫øn to√†n c·ª•c gi·ªØ ti·∫øn tr√¨nh ƒëang ch·∫°y AppRunner
runner_process: Optional[Process] = None


class RunRequest(BaseModel):
    run_minutes: Optional[int] = None
    rest_minutes: Optional[int] = None


def _start_runner(run_minutes: Optional[int] = None, rest_minutes: Optional[int] = None) -> None:
    """H√†m wrapper ƒë·ªÉ ch·∫°y v√≤ng l·∫∑p AppRunner trong ti·∫øn tr√¨nh ri√™ng."""
    AppRunner(run_minutes=run_minutes, rest_minutes=rest_minutes).run()


@app.get("/health")
def health_check() -> dict:
    return {"status": "ok"}


@app.post("/run")
def run_bot(payload: Optional[RunRequest] = Body(None)) -> dict:
    """
    Kh·ªüi ƒë·ªông AppRunner n·∫øu ch∆∞a ch·∫°y.
    Ch·∫°y trong process ri√™ng ƒë·ªÉ kh√¥ng kh√≥a FastAPI.
    """
    global runner_process

    if runner_process and runner_process.is_alive():
        return {"status": "running", "pid": runner_process.pid}

    run_minutes = payload.run_minutes if payload else None
    rest_minutes = payload.rest_minutes if payload else None

    # Kh√¥ng d√πng daemon v√¨ AppRunner t·ª± sinh th√™m Process con
    runner_process = Process(
        target=_start_runner,
        args=(run_minutes, rest_minutes),
        daemon=False,
    )
    runner_process.start()

    if not runner_process.is_alive():
        raise HTTPException(status_code=500, detail="Kh√¥ng kh·ªüi ƒë·ªông ƒë∆∞·ª£c bot")

    return {"status": "started", "pid": runner_process.pid}


@app.post("/stop")
def stop_bot() -> dict:
    """D·ª´ng ti·∫øn tr√¨nh AppRunner n·∫øu ƒëang ch·∫°y."""
    global runner_process

    if not runner_process or not runner_process.is_alive():
        return {"status": "not_running"}

    runner_process.terminate()
    runner_process.join(timeout=5)

    was_alive = runner_process.is_alive()
    runner_process = None

    if was_alive:
        raise HTTPException(status_code=500, detail="Kh√¥ng d·ª´ng ƒë∆∞·ª£c bot")

    return {"status": "stopped"}


@app.get("/status")
def status() -> dict:
    is_running = bool(runner_process and runner_process.is_alive())
    return {"running": is_running, "pid": runner_process.pid if is_running else None}

--- END FILE: app\api.py ---

--- START FILE: app\__init__.py ---
"""
App package cho FastAPI endpoints.
"""

--- END FILE: app\__init__.py ---

--- START FILE: core\browser.py ---
import time
import random
from playwright.sync_api import sync_playwright
import json
import re
from urllib.parse import urlparse, parse_qs, unquote
import os

# ==============================================================================
# JS TOOLS & HELPER FUNCTIONS
# ==============================================================================
JS_EXPAND_SCRIPT = """
(node) => {
    if (!node) return 0;
    const keywords = ["Xem th√™m", "See more"];
    let clickedCount = 0;
    const buttons = node.querySelectorAll('[role="button"]');
    buttons.forEach(btn => {
        const text = btn.innerText ? btn.innerText.trim() : "";
        if (keywords.includes(text)) {
            if (btn.offsetWidth > 0 && btn.offsetHeight > 0) {
                btn.scrollIntoView({block: "center", inline: "nearest"});
                btn.click();
                clickedCount++;
                btn.style.border = "2px solid red";
            }
        }
    });
    return clickedCount;
}
"""

JS_CHECK_AND_HIGHLIGHT_SCOPED = """
([node, keywords]) => { 
    if (!node || !keywords || keywords.length === 0) return false;
    const strictSelectors = [
        '[data-ad-preview="message"]',              
        '[data-ad-rendering-role="story_message"]', 
        '.userContent'                              
    ];
    let targetScope = null;
    for (const selector of strictSelectors) {
        const found = node.querySelector(selector);
        if (found) {
            targetScope = found;
            break;
        }
    }
    if (!targetScope) return false;

    const sortedKeywords = keywords.sort((a, b) => b.length - a.length);
    const pattern = new RegExp(`(${sortedKeywords.join('|')})`, 'gi');
    let foundCount = 0;
    function highlightTextNode(textNode) {
        const text = textNode.nodeValue;
        if (!pattern.test(text)) return;
        const fragment = document.createDocumentFragment();
        const parts = text.split(pattern);
        parts.forEach(part => {
            if (pattern.test(part)) {
                const span = document.createElement('span');
                Object.assign(span.style, {
                    backgroundColor: 'yellow', color: 'red', fontWeight: 'bold',
                    border: '2px solid red', padding: '2px', zIndex: '9999'
                });
                span.innerText = part;
                fragment.appendChild(span);
                foundCount++;
            } else {
                fragment.appendChild(document.createTextNode(part));
            }
            pattern.lastIndex = 0; 
        });
        textNode.parentNode.replaceChild(fragment, textNode);
    }
    const walker = document.createTreeWalker(targetScope, NodeFilter.SHOW_TEXT, {
        acceptNode: n => {
            if (['SCRIPT', 'STYLE', 'NOSCRIPT', 'BUTTON', 'INPUT'].includes(n.parentNode.nodeName)) {
                return NodeFilter.FILTER_REJECT;
            }
            if (n.parentNode.isContentEditable) return NodeFilter.FILTER_REJECT;
            return NodeFilter.FILTER_ACCEPT;
        }
    });
    const textNodes = [];
    while (walker.nextNode()) textNodes.push(walker.currentNode);
    textNodes.forEach(highlightTextNode);
    return foundCount > 0;
}
"""

def extract_facebook_post_id(url: str):
    if not url: return None
    try: url = unquote(url)
    except: pass
    
    # ∆Øu ti√™n t√¨m pfbid tr∆∞·ªõc
    patterns = [
        r"(pfbid[A-Za-z0-9]+)", 
        r"/posts/(\d+)", 
        r"/videos/(\d+)", 
        r"/reel/(\d+)",
        r"story_fbid=(\d+)", 
        r"fbid=(\d+)",
        r"id=(\d+)"
    ]
    for p in patterns:
        m = re.search(p, url)
        if m: return m.group(1)
        
    qs = parse_qs(urlparse(url).query)
    for k in ["story_fbid", "fbid", "id"]:
        if k in qs: return qs[k][0]
    return None

def parse_graphql_payload(post_data):
    """Ph√¢n t√≠ch data g·ª≠i ƒëi ƒë·ªÉ t√¨m bi·∫øn 'url' trong payload."""
    if not post_data: return None
    variables_str = None
    try:
        if isinstance(post_data, str):
            json_body = json.loads(post_data)
        else:
            json_body = post_data
        variables_str = json.dumps(json_body.get("variables", {}))
    except:
        try:
            qs = parse_qs(post_data)
            if "variables" in qs:
                variables_str = qs["variables"][0]
        except: pass

    # T√¨m c√°c lo·∫°i URL ph·ªï bi·∫øn trong payload
    if variables_str:
        # 1. T√¨m key "url": "..."
        match = re.search(r'"url"\s*:\s*"([^"]+)"', variables_str)
        if match: return match.group(1).replace(r"\/", "/")
        
        # 2. T√¨m key "shareable_url": "..."
        match2 = re.search(r'"shareable_url"\s*:\s*"([^"]+)"', variables_str)
        if match2: return match2.group(1).replace(r"\/", "/")

    return None

class FBController:
    def __init__(self, ws_url):
        self.ws_url = ws_url
        self.browser = None
        self.page = None
        self.play = None
        self.profile_id = "unknown"
        
        self.captured_response_id = None 
        self.captured_payload_url = None # Bi·∫øn ch·ª©a Link ƒë·ªÉ soi view-source
        
        self.job_keywords = [
            "tuy·ªÉn d·ª•ng", "tuy·ªÉn nh√¢n vi√™n", "tuy·ªÉn g·∫•p", "vi·ªác l√†m", 
            "l∆∞∆°ng", "thu nh·∫≠p", "ph·ªèng v·∫•n", "cv", "h·ªì s∆°",
            "full-time", "part-time", "th·ª±c t·∫≠p", "k·∫ø to√°n", "may m·∫∑c", "kcn",
            "·ª®ng vi√™n ", "·ª®ng tuy·ªÉn"
        ]

    def connect(self):
        self.play = sync_playwright().start()
        self.browser = self.play.chromium.connect_over_cdp(self.ws_url)
        context = self.browser.contexts[0]
        self.page = context.pages[0]
        
        # √âp c·ª©ng ƒë·ªô ph√¢n gi·∫£i ƒë·ªÉ tr√°nh l·ªói m·∫•t n√∫t Share

        
        self.start_network_sniffer()
        
        try:
            # Click v√†o gi·ªØa m√†n h√¨nh ƒë·ªÉ active window
            viewport = self.page.viewport_size
            self.page.mouse.click(viewport['width']/2, viewport['height']/2)
        except: pass

    def goto(self, url):
        self.page.goto(url, timeout=0)
        # Zoom out ƒë·ªÉ hi·ªán full giao di·ªán
       

    def smooth_scroll_to(self, element):
        """Cu·ªôn m∆∞·ª£t ƒë·∫øn element"""
        try:
            box = element.bounding_box()
            if not box: return
            target_y = box['y'] + self.page.evaluate("window.scrollY") - (self.page.viewport_size['height'] / 2)
            self.page.evaluate(f"window.scrollTo({{top: {target_y}, behavior: 'smooth'}});")
            time.sleep(1.0)
        except:
            element.scroll_into_view_if_needed()

    # ===================== [CORE] NETWORK SNIFFER =====================
    def start_network_sniffer(self):
        print("üõ∞  ƒê√£ k√≠ch ho·∫°t Sniffer: Ch·∫ø ƒë·ªô Response > Payload URL...")

        # 1. B·∫ÆT URL T·ª™ REQUEST (D·ª∞ PH√íNG CHO VIEW-SOURCE)
        def on_request(request):
            if "facebook.com/api/graphql" in request.url and request.method == "POST":
                try:
                    raw_url = parse_graphql_payload(request.post_data)
                    if raw_url:
                        # Ch·ªâ l∆∞u n·∫øu n√≥ gi·ªëng link b√†i vi·∫øt
                        if "facebook.com" in raw_url or "pfbid" in raw_url:
                            self.captured_payload_url = raw_url
                            # print(f"üîó [DEBUG] B·∫Øt ƒë∆∞·ª£c Link ti·ªÅm nƒÉng: {raw_url[:50]}...")
                except: pass

        # 2. B·∫ÆT ID T·ª™ RESPONSE (∆ØU TI√äN TUY·ªÜT ƒê·ªêI)
        def on_response(response):
            if "facebook.com/api/graphql" in response.url and response.status == 200:
                if not self.captured_response_id:
                    try:
                        data = response.json()
                        preview_data = data.get("data", {}).get("xma_preview_data", {})
                        pid = preview_data.get("post_id")
                        if pid:
                            self.captured_response_id = str(pid)
                            print(f"üéØ [RES-Json] B·∫Øt d√≠nh ID CH√çNH TH·ª®C: {self.captured_response_id}")
                    except: pass

        self.page.on("request", on_request)
        self.page.on("response", on_response)

    # ===================== [M·ªöI] H√ÄM SOI VIEW-SOURCE =====================
    def get_id_blocking_mode(self, url):
        """
        M·ªü tab m·ªõi -> Soi Code -> T√¨m ch·ªØ "post_id" ƒë·∫ßu ti√™n -> Tr·∫£ v·ªÅ ngay.
        """
        print(f"‚õî [BLOCKING] T·∫°m d·ª´ng ƒë·ªÉ soi source URL: {url}")
        new_page = None
        found_id = None
        
        try:
            context = self.page.context
            # 1. M·ªü tab m·ªõi
            new_page = context.new_page()
            
            # 2. Truy c·∫≠p view-source (Treo bot ·ªü ƒë√¢y ch·ªù t·∫£i xong m·ªõi ch·∫°y ti·∫øp)
            target = f"view-source:{url}"
            print("    -> ƒêang t·∫£i source code (Ch·ªù DOMContentLoaded)...")
            new_page.goto(target, wait_until='domcontentloaded', timeout=20000)
            
            # 3. L·∫•y to√†n b·ªô HTML
            content = new_page.content()
            
            # 4. T√åM KI·∫æM CH√çNH X√ÅC "post_id"
            # re.search m·∫∑c ƒë·ªãnh s·∫Ω qu√©t t·ª´ tr√™n xu·ªëng d∆∞·ªõi v√† tr·∫£ v·ªÅ k·∫øt qu·∫£ ƒê·∫¶U TI√äN n√≥ th·∫•y.
            # ƒê√∫ng √Ω S·∫øp: Th·∫•y c√°i ƒë·∫ßu l√† ch·ªët lu√¥n.
            
            # Pattern 1: D·∫°ng chu·∫©n "post_id":"12345"
            match = re.search(r'"post_id":"(\d+)"', content)
            
            if match:
                found_id = match.group(1)
                print(f"    -> üíâ B·∫ÆT ƒê∆Ø·ª¢C ID ƒê·∫¶U TI√äN (post_id): {found_id}")
            else:
                # Fallback: N·∫øu kh√¥ng th·∫•y "post_id" th√¨ m·ªõi t√¨m "story_fbid" (d·ª± ph√≤ng)
                match_sub = re.search(r'"story_fbid":"(\d+)"', content)
                if match_sub:
                    found_id = match_sub.group(1)
                    print(f"    -> üíâ Kh√¥ng c√≥ post_id, l·∫•y t·∫°m story_fbid: {found_id}")

            if not found_id:
                print("    -> ‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ID n√†o trong source.")

        except Exception as e:
            print(f"    -> ‚ùå L·ªói khi soi source: {e}")
        finally:
            # 5. ƒê√≥ng tab ngay l·∫≠p t·ª©c
            if new_page: 
                new_page.close()
                print("    -> ƒê√£ ƒë√≥ng tab soi code. Quay l·∫°i tab ch√≠nh...")
                
        return found_id

    # ===================== SHARE & CH·ªú ID (LOGIC UPDATE) =====================
    def share_center_ad(self, post_handle):
        try:
            print("üöÄ ƒêang th·ª±c hi·ªán share ƒë·ªÉ b·∫Øt ID...")
            
            # 1. Reset bi·∫øn
            self.captured_response_id = None
            self.captured_payload_url = None 
            
            # 2. Click n√∫t Share (Tr∆∞·ª£t √™m)
            xpath_selector = 'xpath=.//div[@data-ad-rendering-role="share_button"]/ancestor::div[@role="button"]'
            share_btn = post_handle.query_selector(xpath_selector)
            
            if share_btn:
                self.smooth_scroll_to(share_btn)
                self.page.wait_for_timeout(500) 
                share_btn.click()
                print("‚úÖ ƒê√£ click n√∫t Share. ƒêang ch·ªù Server ph·∫£n h·ªìi...")
                
                # 3. V√≤ng l·∫∑p ch·ªù ID t·ª´ Server (Ch·ªù 5 gi√¢y th√¥i)
                for i in range(25): 
                    if self.captured_response_id:
                        print(f"üéâ SUCCESS: Server tr·∫£ ID chu·∫©n: {self.captured_response_id}")
                        self.save_post_id(self.captured_response_id)
                        
                        self.page.wait_for_timeout(2000)
                        self.page.keyboard.press("Escape")
                        return True
                    self.page.wait_for_timeout(200)
                
                # 4. SERVER KH√îNG TR·∫¢ -> K√çCH HO·∫†T CH·∫æ ƒê·ªò VIEW-SOURCE (BLOCKING)
                print("‚ö†Ô∏è Server kh√¥ng tr·∫£ ID. Ki·ªÉm tra URL d·ª± ph√≤ng...")
                
                if self.captured_payload_url:
                    print(f"üí° C√≥ link trong Payload: {self.captured_payload_url}")
                    
                    # G·ªçi h√†m n√†y l√† bot s·∫Ω T·ª∞ ƒê·ªòNG D·ª™NG m·ªçi vi·ªác kh√°c ƒë·ªÉ ch·ªù
                    source_id = self.get_id_blocking_mode(self.captured_payload_url)
                    
                    if source_id:
                        self.save_post_id(source_id)
                        self.page.wait_for_timeout(1000)
                        self.page.keyboard.press("Escape")
                        return True
                else:
                    print("‚ö†Ô∏è Kh√¥ng b·∫Øt ƒë∆∞·ª£c c·∫£ URL Link -> B√≥ tay.")

                # 5. Th·∫•t b·∫°i
                print("‚ö†Ô∏è SKIP: Kh√¥ng l·∫•y ƒë∆∞·ª£c ID.")
                self.page.keyboard.press("Escape") 
                return False
            else:
                print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y n√∫t Share.")
                return False
                
        except Exception as e:
            print(f"‚ùå L·ªói share_center_ad: {e}")
            self.page.keyboard.press("Escape")
            return False

    def save_post_id(self, post_id):
        try:
            folder = "data/post_ids"
            os.makedirs(folder, exist_ok=True)
            filepath = f"{folder}/{self.profile_id}.json"
            data = []
            if os.path.exists(filepath):
                try:
                    with open(filepath, "r", encoding="utf8") as f: data = json.load(f)
                except: pass
            if post_id in data:
                print("üîÅ ID tr√πng -> b·ªè qua.")
                return False
            data.append(post_id)
            with open(filepath, "w", encoding="utf8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            print(f"üíæ ƒê√£ l∆∞u ID {post_id} v√†o file.")
            return True
        except: return False

    def scroll_percent(self, ratio=0.5):
        """Cu·ªôn trang theo % chi·ªÅu cao"""
        try:
            viewport = self.page.viewport_size
            height = viewport['height'] if viewport else 800
            scroll_distance = int(height * ratio)
            # print(f"‚¨áÔ∏è Cu·ªôn {int(ratio*100)}%...")
            self.page.mouse.wheel(0, scroll_distance)
            return True
        except: return False

    def scan_while_scrolling(self):
        try:
            viewport = self.page.viewport_size
            height = viewport['height'] if viewport else 800
            total_distance = int(height * 0.6) 
            steps = random.randint(15, 25)
            step_size = total_distance / steps
            
            print(f"‚¨áÔ∏è ƒêang l∆∞·ªõt {total_distance}px...")

            for i in range(steps):
                self.page.mouse.wheel(0, step_size)
                time.sleep(random.uniform(0.03, 0.08)) 
                
                if i > 0 and i % 4 == 0:
                    current_post = self.get_center_post()
                    if current_post and self.check_current_post_is_ad(current_post):
                        print(f"üõë B·∫ÆT ƒê∆Ø·ª¢C ADS! (T·∫°i b∆∞·ªõc {i}/{steps})")
                        return current_post
            
            time.sleep(random.uniform(2.0, 3.5))
            return None
        except Exception as e:
            try: self.page.keyboard.press("PageDown"); time.sleep(2)
            except: pass
            return None

    def like_current_post(self, post_handle):
        print("‚ù§Ô∏è ƒêang th·ª±c hi·ªán Like...")
        try:
            element = post_handle.as_element()
            if not element: return False
            already_liked = element.query_selector('div[role="button"][aria-label="G·ª° Th√≠ch"], div[role="button"][aria-label="Remove Like"]')
            if already_liked:
                print("‚ö†Ô∏è ƒê√£ Like r·ªìi.")
                return False
            selector = 'div[role="button"][aria-label="Th√≠ch"], div[role="button"][aria-label="Like"]'
            like_btn = element.query_selector(selector)
            if like_btn:
                self.smooth_scroll_to(like_btn)
                like_btn.click()
                print("‚úÖ Like th√†nh c√¥ng!")
                return True
            return False
        except: return False

    def process_ad_content(self, post_handle):
        try:
            expanded = self.page.evaluate(JS_EXPAND_SCRIPT, post_handle)
            if expanded > 0: time.sleep(1.0)
            has_keyword = self.page.evaluate(JS_CHECK_AND_HIGHLIGHT_SCOPED, [post_handle, self.job_keywords])
            if has_keyword:
                print("    -> ‚úÖ FOUND: B√†i Ads ch·ª©a t·ª´ kh√≥a!")
                return True
            else:
                print("    -> ‚ùå SKIP: Kh√¥ng th·∫•y t·ª´ kh√≥a tuy·ªÉn d·ª•ng.")
                return False
        except: return False

    def get_center_post(self):
        try:
            return self.page.evaluate_handle("""
                () => {
                    const x = window.innerWidth / 2;
                    const y = window.innerHeight * 0.45;
                    let el = document.elementFromPoint(x, y);
                    if (!el) return null;
                    const post = el.closest('div[role="article"], div.x1lliihq');
                    if (post) {
                        post.style.outline = "3px solid #00ff00";
                        return post;
                    }
                    return null;
                }
            """)
        except: return None

    def check_current_post_is_ad(self, post_handle):
        if not post_handle or not post_handle.as_element(): return False
        return post_handle.evaluate("""
            (post) => {
                if (post.getAttribute('data-bot-processed') === 'true') return false;
                const checkAnchors = (element) => {
                    if (!element) return false;
                    const anchors = Array.from(element.querySelectorAll('a[href*="__cft__"]'));
                    for (const a of anchors) {
                        const href = a.getAttribute('href');
                        if (!href) continue;
                        if (href.includes('__tn__')) continue;
                        let m = href.match(/__cft__\\[0\\]=([^&#]+)/) || href.match(/__cft__%5B0%5D=([^&#]+)/);
                        if (m && m[1]) return true; 
                    }
                    return false;
                };
                if (checkAnchors(post)) { post.style.outline = "5px solid red"; return true; }
                if (post.parentElement && checkAnchors(post.parentElement)) { post.style.outline = "5px solid red"; return true; }
                if (post.parentElement && post.parentElement.parentElement && checkAnchors(post.parentElement.parentElement)) { post.style.outline = "5px solid red"; return true; }
                return false;
            }
        """)

    def mark_post_as_processed(self, post_handle):
        try:
            post_handle.evaluate("""(post) => {
                post.setAttribute('data-bot-processed', 'true');
                post.style.outline = "5px solid gray"; 
                post.style.opacity = "0.7";
            }""")
            # print("üèÅ ƒê√£ ƒë√°nh d·∫•u b√†i vi·∫øt: DONE.")
        except: pass
--- END FILE: core\browser.py ---

--- START FILE: core\nst.py ---
import requests
import os
import json
import urllib.parse # C·∫ßn c√°i n√†y ƒë·ªÉ m√£ h√≥a User-Agent c√≥ d·∫•u c√°ch
from dotenv import load_dotenv

load_dotenv()

API_KEY = os.getenv("API_KEY")
HEADLESS = os.getenv("HEADLESS", "false").lower() == "true"

def connect_profile(profile_id: str):
    # C·∫•u h√¨nh chu·∫©n theo JS m·∫´u: D√πng fingerprint ƒë·ªÉ fake User-Agent
    # KH√îNG d√πng 'args' ƒë·ªÉ tr√°nh b·ªã hi·ªán UI
    config = {
        "headless": HEADLESS,
        "autoClose": True,
        "fingerprint": {
            # User-Agent x·ªãn ƒë·ªÉ qua m·∫∑t Facebook
            "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "hardwareConcurrency": 8,
            "deviceMemory": 8
        }
    }

    # M√£ h√≥a config th√†nh chu·ªói an to√†n cho URL (v√¨ User-Agent c√≥ d·∫•u c√°ch)
    encoded_config = urllib.parse.quote(json.dumps(config))

    url = f"http://127.0.0.1:8848/api/v2/connect/{profile_id}?x-api-key={API_KEY}&config={encoded_config}"

    print(f"üöÄ M·ªü profile {profile_id} (headless={HEADLESS})")

    # Th·ª≠ k·∫øt n·ªëi
    try:
        resp = requests.get(url, timeout=20)
        data = resp.json()

        if data.get("err"):
            raise Exception(f"‚ùå NST Error: {data.get('err')}")

        ws = data["data"]["webSocketDebuggerUrl"]
        print(f"üîå WebSocket: {ws}")
        return ws
        
    except Exception as e:
        print(f"‚ùå L·ªói k·∫øt n·ªëi: {e}")
        raise e
--- END FILE: core\nst.py ---

--- START FILE: core\runner.py ---
import os
import time  # [C·∫ßn th√™m th∆∞ vi·ªán n√†y ƒë·ªÉ ƒë·∫øm gi·ªù]
from multiprocessing import Process
from typing import Optional

from dotenv import load_dotenv

from core.browser import FBController
from core.nst import connect_profile
from core.scraper import SimpleBot
from core.utils import clean_profile_list


class AppRunner:
    def __init__(self, run_minutes: Optional[int] = None, rest_minutes: Optional[int] = None):
        load_dotenv()
        self.target_url = os.getenv("TARGET_URL", "https://facebook.com")
        self.profiles = clean_profile_list(os.getenv("PROFILE_IDS", ""))

        # ∆Øu ti√™n gi√° tr·ªã truy·ªÅn t·ª´ API; fallback ENV; cu·ªëi c√πng l√† default.
        self.RUN_MINUTES = self._coerce_positive_int(
            run_minutes,
            self._coerce_positive_int(os.getenv("RUN_MINUTES"), 30),
            default=30,
        )
        # REST_MINUTES m·∫∑c ƒë·ªãnh 120p (t∆∞∆°ng ƒë∆∞∆°ng 2h nh∆∞ c·∫•u h√¨nh c≈©)
        self.REST_MINUTES = self._coerce_positive_int(
            rest_minutes,
            self._coerce_positive_int(os.getenv("REST_MINUTES"), 120),
            default=120,
        )

    @staticmethod
    def _coerce_positive_int(value, fallback=None, default=0):
        """
        Tr·∫£ v·ªÅ s·ªë nguy√™n d∆∞∆°ng; n·∫øu kh√¥ng h·ª£p l·ªá d√πng fallback, cu·ªëi c√πng d√πng default.
        """
        for candidate in (value, fallback, default):
            try:
                num = int(candidate)
                if num > 0:
                    return num
            except (TypeError, ValueError):
                continue
        return default

    def worker(self, profile_id):
        """H√†m x·ª≠ l√Ω cho t·ª´ng profile (Process con)"""
        try:
            # 1. K·∫øt n·ªëi NST
            ws = connect_profile(profile_id)

            # 2. Kh·ªüi t·∫°o tr√¨nh duy·ªát
            fb = FBController(ws)
            fb.profile_id = profile_id
            fb.connect()

            # 3. Ch·∫°y bot t∆∞∆°ng t√°c
            bot = SimpleBot(fb)
            
            # ƒê·ªïi th·ªùi gian ch·∫°y sang gi√¢y
            duration_seconds = self.RUN_MINUTES * 60
            
            # Bot s·∫Ω t·ª± tho√°t v√≤ng l·∫∑p sau khi ƒë·ªß th·ªùi gian
            bot.run(self.target_url, duration=duration_seconds) 

            print(f"‚úÖ [{profile_id}] ƒê√£ ch·∫°y ƒë·ªß {self.RUN_MINUTES} ph√∫t. ƒêang t·∫Øt tr√¨nh duy·ªát...")
            
            # [Quan tr·ªçng] ƒê√≥ng tr√¨nh duy·ªát s·∫°ch s·∫Ω ƒë·ªÉ gi·∫£i ph√≥ng RAM
            try:
                if fb.browser: fb.browser.close()
                if fb.play: fb.play.stop()
            except: pass
            
        except Exception as e:
            print(f"‚ùå L·ªói ·ªü profile {profile_id}: {e}")

    def run(self):
        """H√†m ƒëi·ªÅu ph·ªëi ch√≠nh (V√≤ng l·∫∑p vƒ©nh c·ª≠u)"""
        
        # ƒê·ªïi th·ªùi gian ngh·ªâ sang gi√¢y
        rest_seconds = self.REST_MINUTES * 60
        
        print(f"‚àû K√≠ch ho·∫°t ch·∫ø ƒë·ªô nu√¥i tu·∫ßn ho√†n: Ch·∫°y {self.RUN_MINUTES}p -> Ngh·ªâ {self.REST_MINUTES}p")

        while True:
            print("="*60)
            print(f"‚ñ∂Ô∏è [START] B·∫Øt ƒë·∫ßu phi√™n ch·∫°y m·ªõi l√∫c {time.strftime('%H:%M:%S')}")
            print("="*60)

            # 1. Kh·ªüi ch·∫°y d√†n profile
            processes = []
            for pid in self.profiles:
                p = Process(target=self.worker, args=(pid,))
                p.start()
                processes.append(p)

            # 2. Ch·ªù t·∫•t c·∫£ c√°c profile ch·∫°y xong (H·∫øt 30 ph√∫t t·ª•i n√≥ s·∫Ω t·ª± d·ª´ng)
            for p in processes:
                p.join()

            # 3. T√≠nh to√°n th·ªùi gian th·ª©c d·∫≠y
            wake_up_time = time.time() + rest_seconds
            wake_up_str = time.strftime('%H:%M:%S', time.localtime(wake_up_time))

            print("\n" + "="*60)
            print(f"üí§ [SLEEP] Xong phi√™n n√†y. Bot s·∫Ω ng·ªß {self.REST_MINUTES} ph√∫t.")
            print(f"‚è∞ D·ª± ki·∫øn ch·∫°y l·∫°i v√†o l√∫c: {wake_up_str}")
            print("="*60 + "\n")
            
            # 4. Bot ƒëi ng·ªß
            time.sleep(rest_seconds)
--- END FILE: core\runner.py ---

--- START FILE: core\scraper.py ---
import time
import random
import os

class SimpleBot:
    def __init__(self, fb):
        self.fb = fb 

    def run(self, url, duration=None):
        print(f"üöÄ ƒêang truy c·∫≠p: {url}")
        self.fb.goto(url) 
        
        start_time = time.time()
        
        # [THAY ƒê·ªîI] Kh√¥ng c·∫ßn ƒë·∫øm s·ªë l·∫ßn cu·ªôn ƒë·ªÉ like random n·ªØa
        # press_count = 0 
        
        while True:
            try:
                # 1. Ki·ªÉm tra th·ªùi gian ch·∫°y
                if duration and (time.time() - start_time > duration):
                    print("‚è≥ H·∫øt gi·ªù ch·∫°y.")
                    break

                # ============================================================
                # CHI·∫æN THU·∫¨T: SCAN & SCROLL
                # ============================================================
                
                # Bot t·ª± ƒë·ªông cu·ªôn, n·∫øu th·∫•y Ads th√¨ d·ª´ng l·∫°i tr·∫£ v·ªÅ element
                detected_ad = self.fb.scan_while_scrolling()
                
                # ============================================================
                # TR∆Ø·ªúNG H·ª¢P: B·∫ÆT ƒê∆Ø·ª¢C ADS
                # ============================================================
                if detected_ad:
                    print("\n>>> üéØ B·∫ÆT ƒê∆Ø·ª¢C ADS KHI ƒêANG TR∆Ø·ª¢T!")
                    
                    # Ki·ªÉm tra xem Ads c√≥ ch·ª©a t·ª´ kh√≥a m·ª•c ti√™u kh√¥ng
                    is_valid_ad = self.fb.process_ad_content(detected_ad)
                    
                    if is_valid_ad:
                        print("‚úÖ Ads n√†y NGON (ƒë√∫ng t·ª´ kh√≥a) -> Ti·∫øn h√†nh LIKE & SHARE!")
                        
                        # --- [S·ª¨A ƒê·ªîI] B∆Ø·ªöC 1: LIKE TR∆Ø·ªöC ---
                        self.fb.like_current_post(detected_ad)
                        time.sleep(random.uniform(1.0, 2.0)) # Ngh·ªâ nh·ªãp nh·∫π cho gi·ªëng ng∆∞·ªùi

                        # --- [S·ª¨A ƒê·ªîI] B∆Ø·ªöC 2: SHARE SAU ---
                        self.fb.share_center_ad(detected_ad)
                        time.sleep(2)
                    else:
                        print("‚ùå Ads n√†y kh√¥ng ch·ª©a t·ª´ kh√≥a -> B·ªè qua kh√¥ng Like/Share.")
                    
                    # ƒê√°nh d·∫•u ƒë√£ x·ª≠ l√Ω ƒë·ªÉ kh√¥ng qu√©t l·∫°i
                    self.fb.mark_post_as_processed(detected_ad)
                    
                    # X·ª≠ l√Ω xong th√¨ cu·ªôn m·∫°nh ƒë·ªÉ qua b√†i
                    print("üëã Xong b√†i n√†y -> Cu·ªôn ti·∫øp...")
                   
                    time.sleep(1.5)
                    
                    continue

                # ============================================================
                # [ƒê√É T·∫ÆT] LOGIC LIKE RANDOM B√ÄI TH∆Ø·ªúNG
                # ============================================================
                # Em ƒë√£ comment ph·∫ßn n√†y ƒë·ªÉ bot t·∫≠p trung Like Ads chu·∫©n ch·ªâ h∆°n.
                # N·∫øu S·∫øp mu·ªën bot like d·∫°o cho "trust" acc th√¨ m·ªü l·∫°i ƒëo·∫°n d∆∞·ªõi nh√©.
                
                """
                press_count += 1
                if press_count >= random.randint(5, 10):
                    # Logic c≈©: Like b√†i th∆∞·ªùng
                    pass 
                """

                # Random mouse move nh·∫π cho ƒë·ª° b·ªã check bot
                if random.random() < 0.1:
                    try:
                        vp = self.fb.page.viewport_size
                        if vp: self.fb.page.mouse.move(random.randint(0, vp['width']), random.randint(0, vp['height']))
                    except: pass
            
            except Exception as e:
                print(f"‚ùå L·ªói v√≤ng l·∫∑p: {e}")
                time.sleep(2)
--- END FILE: core\scraper.py ---

--- START FILE: core\utils.py ---


import re

def extract_uid_from_url(url):
    """
    Chuy·ªÉn ƒë·ªïi link profile th√†nh UID ho·∫∑c Username
    V√≠ d·ª•: 
    - https://www.facebook.com/profile.php?id=10001234 -> 10001234
    - https://www.facebook.com/zuck?comment_id=... -> zuck
    """
    if not url: return None
    
    # Tr∆∞·ªùng h·ª£p 1: profile.php?id=12345
    match_id = re.search(r'profile\.php\?id=(\d+)', url)
    if match_id:
        return match_id.group(1)
        
    # Tr∆∞·ªùng h·ª£p 2: facebook.com/username
    # Lo·∫°i b·ªè c√°c tham s·ªë r√°c sau d·∫•u ? ho·∫∑c &
    clean_url = url.split('?')[0].split('&')[0]
    parts = clean_url.rstrip('/').split('/')
    
    # L·∫•y ph·∫ßn cu·ªëi c√πng (username)
    if parts:
        user_part = parts[-1]
        if user_part not in ['facebook.com', 'www.facebook.com', '']:
            return user_part
            
    return None

def clean_profile_list(raw: str):
    return [p.strip() for p in raw.split(",") if p.strip()]
--- END FILE: core\utils.py ---

--- START FILE: data\post_ids\031ca13d-e8fa-400c-a603-df57a2806788.json ---
[
  "122150960222694490",
  "101620679431321",
  "1171101481878307",
  "122152251362694490",
  "120235170330520148",
  "1506669197252501",
  "122282148692021742",
  "122152251422694490",
  "445523486001318",
  "122103851445151875",
  "819804580808502"
]
--- END FILE: data\post_ids\031ca13d-e8fa-400c-a603-df57a2806788.json ---

--- START FILE: data\post_ids\621e1f5d-0c42-481e-9ddd-7abaafce68ed.json ---
[]
--- END FILE: data\post_ids\621e1f5d-0c42-481e-9ddd-7abaafce68ed.json ---

